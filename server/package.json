{
  "name": "react-server-example",
  "version": "1.0.6",
  "description": "A very simple implementation of server-side React rendering",
  "main": "server.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/mhart/react-server-example"
  },
  "keywords": [
    "react",
    "reactjs",
    "server",
    "server-side"
  ],
  "author": {
    "name": "Michael Hart",
    "email": "michael.hart.au@gmail.com"
  },
  "license": "MIT",
  "dependencies": {
    "browserify": "^10.1.3",
    "literalify": "^0.4.0",
    "react": "^0.13.3"
  },
  "scripts": {
    "start": "node server.js"
  },
  "readme": "react-server-example\n--------------------\n\nA simple (no compile) example of how to do server-side rendering with the\n[React](http://facebook.github.io/react/) library so that component code can be\nshared between server and browser, as well as getting fast initial page loads\nand search-engine-friendly pages.\n\nA more complex example with shared routing and data fetching can be found at\n[react-server-routing-example](https://github.com/mhart/react-server-routing-example).\n\nExample\n-------\n\n```sh\n$ node server.js\n```\n\nThen navigate to [http://localhost:3000](http://localhost:3000) and\nclick on the button to see some reactive events in action.\n\nTry viewing the page source to ensure the HTML being sent from the server is already rendered\n(with checksums to determine whether client-side rendering is necessary)\n\nHere are the files involved:\n\n`App.js`:\n```js\nvar React = require('react'),\n    DOM = React.DOM, div = DOM.div, button = DOM.button, ul = DOM.ul, li = DOM.li\n\n// This is just a simple example of a component that can be rendered on both\n// the server and browser\n\nmodule.exports = React.createClass({\n\n  // We initialise its state by using the `props` that were passed in when it\n  // was first rendered. We also want the button to be disabled until the\n  // component has fully mounted on the DOM\n  getInitialState: function() {\n    return {items: this.props.items, disabled: true}\n  },\n\n  // Once the component has been mounted, we can enable the button\n  componentDidMount: function() {\n    this.setState({disabled: false})\n  },\n\n  // Then we just update the state whenever its clicked by adding a new item to\n  // the list - but you could imagine this being updated with the results of\n  // AJAX calls, etc\n  handleClick: function() {\n    this.setState({\n      items: this.state.items.concat('Item ' + this.state.items.length)\n    })\n  },\n\n  // For ease of illustration, we just use the React JS methods directly\n  // (no JSX compilation needed)\n  // Note that we allow the button to be disabled initially, and then enable it\n  // when everything has loaded\n  render: function() {\n\n    return div(null,\n\n      button({onClick: this.handleClick, disabled: this.state.disabled}, 'Add Item'),\n\n      ul({children: this.state.items.map(function(item) {\n        return li(null, item)\n      })})\n\n    )\n  },\n})\n```\n\n`browser.js`:\n```js\nvar React = require('react'),\n    // This is our React component, shared by server and browser thanks to browserify\n    App = React.createFactory(require('./App'))\n\n// This script will run in the browser and will render our component using the\n// value from APP_PROPS that we generate inline in the page's html on the server.\n// If these props match what is used in the server render, React will see that\n// it doesn't need to generate any DOM and the page will load faster\n\nReact.render(App(window.APP_PROPS), document.getElementById('content'))\n```\n\n`server.js`:\n```js\nvar http = require('http'),\n    browserify = require('browserify'),\n    literalify = require('literalify'),\n    React = require('react'),\n    DOM = React.DOM, body = DOM.body, div = DOM.div, script = DOM.script,\n    // This is our React component, shared by server and browser thanks to browserify\n    App = React.createFactory(require('./App'))\n\n\n// Just create a plain old HTTP server that responds to two endpoints ('/' and\n// '/bundle.js') This would obviously work similarly with any higher level\n// library (Express, etc)\nhttp.createServer(function(req, res) {\n\n  // If we hit the homepage, then we want to serve up some HTML - including the\n  // server-side rendered React component(s), as well as the script tags\n  // pointing to the client-side code\n  if (req.url == '/') {\n\n    res.setHeader('Content-Type', 'text/html')\n\n    // `props` represents the data to be passed in to the React component for\n    // rendering - just as you would pass data, or expose variables in\n    // templates such as Jade or Handlebars.  We just use some dummy data\n    // here (with some potentially dangerous values for testing), but you could\n    // imagine this would be objects typically fetched async from a DB,\n    // filesystem or API, depending on the logged-in user, etc.\n    var props = {\n      items: [\n        'Item 0',\n        'Item 1',\n        'Item </script>',\n        'Item <!--inject!-->',\n      ]\n    }\n\n    // Here we're using React to render the outer body, so we just use the\n    // simpler renderToStaticMarkup function, but you could use any templating\n    // language (or just a string) for the outer page template\n    var html = React.renderToStaticMarkup(body(null,\n\n      // The actual server-side rendering of our component occurs here, and we\n      // pass our data in as `props`. This div is the same one that the client\n      // will \"render\" into on the browser from browser.js\n      div({id: 'content', dangerouslySetInnerHTML: {__html:\n        React.renderToString(App(props))\n      }}),\n\n      // The props should match on the client and server, so we stringify them\n      // on the page to be available for access by the code run in browser.js\n      // You could use any var name here as long as it's unique\n      script({dangerouslySetInnerHTML: {__html:\n        'var APP_PROPS = ' + safeStringify(props) + ';'\n      }}),\n\n      // We'll load React from a CDN - you don't have to do this,\n      // you can bundle it up or serve it locally if you like\n      script({src: '//fb.me/react-0.13.3.min.js'}),\n\n      // Then the browser will fetch and run the browserified bundle consisting\n      // of browser.js and all its dependencies.\n      // We serve this from the endpoint a few lines down.\n      script({src: '/bundle.js'})\n    ))\n\n    // Return the page to the browser\n    res.end(html)\n\n  // This endpoint is hit when the browser is requesting bundle.js from the page above\n  } else if (req.url == '/bundle.js') {\n\n    res.setHeader('Content-Type', 'text/javascript')\n\n    // Here we invoke browserify to package up browser.js and everything it requires.\n    // DON'T do it on the fly like this in production - it's very costly -\n    // either compile the bundle ahead of time, or use some smarter middleware\n    // (eg browserify-middleware).\n    // We also use literalify to transform our `require` statements for React\n    // so that it uses the global variable (from the CDN JS file) instead of\n    // bundling it up with everything else\n    browserify()\n      .add('./browser.js')\n      .transform(literalify.configure({react: 'window.React'}))\n      .bundle()\n      .pipe(res)\n\n  // Return 404 for all other requests\n  } else {\n    res.statusCode = 404\n    res.end()\n  }\n\n// The http server listens on port 3000\n}).listen(3000, function(err) {\n  if (err) throw err\n  console.log('Listening on 3000...')\n})\n\n\n// A utility function to safely escape JSON for embedding in a <script> tag\nfunction safeStringify(obj) {\n  return JSON.stringify(obj).replace(/<\\/script/g, '<\\\\/script').replace(/<!--/g, '<\\\\!--')\n}\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mhart/react-server-example/issues"
  },
  "_id": "react-server-example@1.0.6",
  "dist": {
    "shasum": "2550703763281624b6f4ac76d70761e060510d27"
  },
  "_from": "react-server-example@",
  "_resolved": "https://registry.npmjs.org/react-server-example/-/react-server-example-1.0.6.tgz"
}
